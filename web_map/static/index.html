<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Web Map Editor</title>
  <style>
    html, body { margin:0; padding:0; height:100%; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #root { display:flex; height:100%; width:100%; background:#ECF0F4; color:#222; }
    #sidebar { width:280px; background:#F5F6FA; border-left:1px solid #D7DCE3; padding:14px; box-sizing:border-box; }
    #canvasWrap { flex:1; position:relative; overflow:hidden; }
    #c { background:transparent; display:block; width:100%; height:100%; }
    h1 { font-size:16px; margin:0 0 10px; font-weight:600; }
    .row { margin:8px 0; }
    .btn { padding:8px 10px; background:#2D7AF0; color:#fff; border:none; border-radius:6px; cursor:pointer; }
    .btn.secondary { background:#6B7280; }
    .label { font-size:12px; color:#444; margin-bottom:6px; display:block; }
    input[type=text] { width:100%; padding:8px; border:1px solid #D7DCE3; border-radius:6px; background:#fff; box-sizing:border-box; }
    .small { font-size:12px; color:#666; }
  </style>
</head>
<body>
  <div id="root">
    <div id="canvasWrap">
      <canvas id="c"></canvas>
      <canvas id="overlay"></canvas>
    </div>
    <div id="sidebar">
      <h1>Web Map</h1>
      <div class="row">
        <span class="label">Actions</span>
        <button id="btnGen" class="btn">Generate</button>
        <button id="btnInp" class="btn secondary">Inpaint</button>
      </div>
      <div class="row">
        <span class="label">Inpaint mode</span>
        <select id="inpMode">
          <option value="whole">Whole selection</option>
          <option value="brush">Brush mask</option>
        </select>
      </div>
      <div class="row">
        <span class="label">Block layer</span>
        <button id="layerBtn" class="btn">Layer: <span id="layerTxt">0</span></button>
      </div>
      <div class="row">
        <button id="btnLayerAdd" class="btn">Add to layer</button>
        <button id="btnLayerRemove" class="btn secondary">Remove from layer</button>
      </div>
      <div class="row">
        <button id="btnDelete" class="btn secondary">Delete tiles</button>
      </div>
      <div class="row">
        <span class="label">Prompt</span>
        <input id="prompt" type="text" placeholder="Describe tiles..." />
      </div>
      <div class="row small">LMB drag: select • LMB click: run • RMB drag: pan • Wheel: zoom</div>
      <div class="row"><button id="save" class="btn secondary">Save</button></div>
    </div>
  </div>

  <script>
    const c = document.getElementById('c');
    const overlay = document.getElementById('overlay');
    const wrap = document.getElementById('canvasWrap');
    const ctx = c.getContext('2d');
    const octx = overlay.getContext('2d');
    const btnGen = document.getElementById('btnGen');
    const btnInp = document.getElementById('btnInp');
    const inpMode = document.getElementById('inpMode');
    const layerBtn = document.getElementById('layerBtn');
    const layerTxt = document.getElementById('layerTxt');
    const promptEl = document.getElementById('prompt');
    const saveBtn = document.getElementById('save');
    const btnLayerAdd = document.getElementById('btnLayerAdd');
    const btnLayerRemove = document.getElementById('btnLayerRemove');
    const btnDelete = document.getElementById('btnDelete');

    let layer = 0;
    let tile = 32, gw = 120, gh = 68;
    let cam = {x:0, y:0}, zoom = 1;
    let patches = [];
    let sel = {active:false, has:false, sx:0, sy:0, ex:0, ey:0};
    let rdrag = false, lastMouse = null;
    let state = null;
    let painting = false;
    let brushSize = 12;

    function resize() {
      c.width = wrap.clientWidth;
      c.height = wrap.clientHeight;
      overlay.width = wrap.clientWidth;
      overlay.height = wrap.clientHeight;
      draw();
    }
    window.addEventListener('resize', resize);

    function worldToScreen(x, y) {
      return {
        x: Math.floor((x * tile - cam.x) * zoom),
        y: Math.floor((y * tile - cam.y) * zoom)
      };
    }
    function screenToCell(mx, my) {
      const wx = cam.x + mx / Math.max(zoom, 1e-6);
      const wy = cam.y + my / Math.max(zoom, 1e-6);
      const cx = Math.max(0, Math.min(gw-1, Math.floor(wx / tile)));
      const cy = Math.max(0, Math.min(gh-1, Math.floor(wy / tile)));
      return {x:cx, y:cy};
    }

    function drawGrid() {
      const step = Math.floor(tile * zoom);
      if (step < 8) return;
      ctx.strokeStyle = '#B4BCC8';
      ctx.lineWidth = 1;
      const x0 = -Math.floor(cam.x * zoom) % Math.max(step, 1);
      const y0 = -Math.floor(cam.y * zoom) % Math.max(step, 1);
      ctx.beginPath();
      for (let x = x0; x < c.width; x += step) { ctx.moveTo(x,0); ctx.lineTo(x,c.height); }
      for (let y = y0; y < c.height; y += step) { ctx.moveTo(0,y); ctx.lineTo(c.width,y); }
      ctx.stroke();
    }

    function draw() {
      ctx.clearRect(0,0,c.width,c.height);
      octx.clearRect(0,0,overlay.width, overlay.height);
      // draw existing patches
      for (const p of patches) {
        const img = p._img;
        if (!img) continue;
        const pos = worldToScreen(p.x, p.y);
        const w = Math.floor(p.w * tile * zoom);
        const h = Math.floor(p.h * tile * zoom);
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, pos.x, pos.y, w, h);
      }
      drawGrid();
      if (sel.active || sel.has) {
        const x0 = Math.min(sel.sx, sel.ex), y0 = Math.min(sel.sy, sel.ey);
        const w = Math.abs(sel.ex - sel.sx) + 1, h = Math.abs(sel.ey - sel.sy) + 1;
        const pos = worldToScreen(x0, y0);
        ctx.strokeStyle = '#1E78FF';
        ctx.lineWidth = 2;
        ctx.strokeRect(pos.x, pos.y, Math.floor(w*tile*zoom), Math.floor(h*tile*zoom));
      }
    }

    async function fetchState() {
      const r = await fetch('/api/state');
      state = await r.json();
      tile = state.tile_size; gw = state.grid_width; gh = state.grid_height;
      patches = state.layers.patches || [];
      for (const p of patches) {
        const img = new Image();
        img.src = p.url || p.file;
        await img.decode().catch(()=>{});
        p._img = img;
      }
      draw();
    }

    // Mouse
    c.addEventListener('contextmenu', e => e.preventDefault());
    c.addEventListener('mousedown', (e) => {
      if (e.button === 2) { rdrag = true; lastMouse = {x:e.clientX, y:e.clientY}; return; }
      if (e.button === 0) {
        const cell = screenToCell(e.offsetX, e.offsetY);
        sel.active = true; sel.has = true; sel.sx = sel.ex = cell.x; sel.sy = sel.ey = cell.y;
        draw();
      }
    });
    c.addEventListener('mouseup', async (e) => {
      if (e.button === 2) { rdrag = false; lastMouse = null; return; }
      if (e.button === 0) { sel.active = false; draw(); }
    });
    c.addEventListener('mousemove', (e) => {
      if (rdrag && lastMouse) {
        const dx = e.clientX - lastMouse.x, dy = e.clientY - lastMouse.y;
        cam.x -= dx / Math.max(zoom, 1e-6);
        cam.y -= dy / Math.max(zoom, 1e-6);
        lastMouse = {x:e.clientX, y:e.clientY};
        draw();
        return;
      }
      if (sel.active) {
        const cell = screenToCell(e.offsetX, e.offsetY);
        sel.ex = cell.x; sel.ey = cell.y; draw();
      }
    });

    // Brush painting on overlay if mode=brush and selection fixed
    overlay.addEventListener('mousedown', (e) => {
      if (inpMode.value !== 'brush') return;
      if (!sel.has || sel.active) return;
      if (e.button !== 0) return;
      painting = true;
      paintAt(e.offsetX, e.offsetY);
    });
    overlay.addEventListener('mousemove', (e) => {
      if (!painting) return;
      paintAt(e.offsetX, e.offsetY);
    });
    overlay.addEventListener('mouseup', () => { painting = false; });
    overlay.addEventListener('mouseleave', () => { painting = false; });

    function paintAt(mx, my) {
      const cell = screenToCell(mx, my);
      const x0 = Math.min(sel.sx, sel.ex), y0 = Math.min(sel.sy, sel.ey);
      const px = (cell.x - x0) * tile;
      const py = (cell.y - y0) * tile;
      const pos = worldToScreen(cell.x, cell.y);
      const r = Math.max(2, Math.floor(brushSize * zoom));
      octx.fillStyle = 'rgba(255,255,255,1)';
      octx.beginPath();
      octx.arc(pos.x + Math.floor(tile*zoom/2), pos.y + Math.floor(tile*zoom/2), r, 0, Math.PI*2);
      octx.fill();
    }
    c.addEventListener('wheel', (e) => {
      const k = e.deltaY < 0 ? 1.1 : 1/1.1;
      zoom = Math.max(0.25, Math.min(4.0, zoom * k));
      draw();
    }, {passive:true});

    // UI actions
    btnGen.onclick = async () => {
      if (!sel.has) return;
      const def = promptEl.value || '';
      const p = window.prompt('Generation prompt', def);
      if (p === null) return;
      const x0 = Math.min(sel.sx, sel.ex), y0 = Math.min(sel.sy, sel.ey);
      const w = Math.abs(sel.ex - sel.sx) + 1, h = Math.abs(sel.ey - sel.sy) + 1;
      const body = {x:x0, y:y0, w, h, prompt: p};
      const r = await fetch('/api/generate', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
      const out = await r.json();
      for (const pch of out.patches || []) {
        const img = new Image(); img.src = pch.url || pch.file; await img.decode().catch(()=>{}); pch._img = img; patches.push(pch);
      }
      draw();
    };
    btnInp.onclick = async () => {
      if (!sel.has) return;
      const def = promptEl.value || '';
      const p = window.prompt('Inpaint prompt (optional)', def);
      if (p === null) return; // user cancelled
      const x0 = Math.min(sel.sx, sel.ex), y0 = Math.min(sel.sy, sel.ey);
      const w = Math.abs(sel.ex - sel.sx) + 1, h = Math.abs(sel.ey - sel.sy) + 1;
      let mask_base64 = null;
      if (inpMode.value === 'brush') {
        const maskCanvas = document.createElement('canvas');
        maskCanvas.width = w * tile;
        maskCanvas.height = h * tile;
        const mctx = maskCanvas.getContext('2d');
        mctx.fillStyle = 'black';
        mctx.fillRect(0,0,maskCanvas.width, maskCanvas.height);
        const sx = Math.floor((Math.min(sel.sx, sel.ex) * tile - cam.x) * zoom);
        const sy = Math.floor((Math.min(sel.sy, sel.ey) * tile - cam.y) * zoom);
        const sw = Math.floor(w * tile * zoom);
        const sh = Math.floor(h * tile * zoom);
        mctx.imageSmoothingEnabled = false;
        mctx.drawImage(overlay, sx, sy, sw, sh, 0, 0, maskCanvas.width, maskCanvas.height);
        // autocrop to painted bbox and pad to tile grid
        const imgData = mctx.getImageData(0,0,maskCanvas.width, maskCanvas.height);
        let minX = maskCanvas.width, minY = maskCanvas.height, maxX = -1, maxY = -1;
        for (let y=0; y<imgData.height; y++) {
          for (let x=0; x<imgData.width; x++) {
            const i = (y*imgData.width + x)*4;
            const a = imgData.data[i+3];
            if (a > 0) { if (x<minX) minX=x; if (y<minY) minY=y; if (x>maxX) maxX=x; if (y>maxY) maxY=y; }
          }
        }
        if (maxX >= minX && maxY >= minY) {
          const gx0 = Math.floor(minX / tile); const gy0 = Math.floor(minY / tile);
          const gx1 = Math.ceil((maxX+1) / tile); const gy1 = Math.ceil((maxY+1) / tile);
          const cropX = gx0 * tile, cropY = gy0 * tile;
          const cropW = (gx1 - gx0) * tile, cropH = (gy1 - gy0) * tile;
          const cropped = document.createElement('canvas');
          cropped.width = cropW; cropped.height = cropH;
          const cctx = cropped.getContext('2d');
          cctx.putImageData(mctx.getImageData(cropX, cropY, cropW, cropH), 0, 0);
          mask_base64 = cropped.toDataURL('image/png').split(',')[1];
          // adjust selection to cropped region so server places patch correctly
          const dx = gx0; const dy = gy0;
          sel.sx = sel.ex = x0 + dx; sel.sy = sel.ey = y0 + dy; // temporary for placement
        } else {
          mask_base64 = null;
        }
      }
      const body = {x:x0, y:y0, w, h, prompt: p, mask_base64};
      const r = await fetch('/api/inpaint', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
      const out = await r.json();
      for (const pch of out.patches || []) {
        const img = new Image(); img.src = pch.url || pch.file; await img.decode().catch(()=>{}); pch._img = img; patches.push(pch);
      }
      draw();
    };
    layerBtn.onclick = () => { layer = 1-layer; layerTxt.textContent = String(layer); };
    btnLayerAdd.onclick = async () => {
      if (!sel.has || !state) return;
      const x0 = Math.min(sel.sx, sel.ex), y0 = Math.min(sel.sy, sel.ey);
      const w = Math.abs(sel.ex - sel.sx) + 1, h = Math.abs(sel.ey - sel.sy) + 1;
      const arr = layer === 0 ? state.layers.collision_layer_1 : state.layers.collision_layer_2;
      const setKey = new Set(arr.map(p => p.join(',')));
      for (let y=y0; y<y0+h; y++) for (let x=x0; x<x0+w; x++) setKey.add(`${x},${y}`);
      const out = Array.from(setKey).map(s => s.split(',').map(Number)).sort((a,b)=>a[1]-b[1]||a[0]-b[0]);
      if (layer === 0) state.layers.collision_layer_1 = out; else state.layers.collision_layer_2 = out;
      await fetch('/api/state', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({data: state})});
      draw();
    };
    btnLayerRemove.onclick = async () => {
      if (!sel.has || !state) return;
      const x0 = Math.min(sel.sx, sel.ex), y0 = Math.min(sel.sy, sel.ey);
      const w = Math.abs(sel.ex - sel.sx) + 1, h = Math.abs(sel.ey - sel.sy) + 1;
      const arr = layer === 0 ? state.layers.collision_layer_1 : state.layers.collision_layer_2;
      const out = [];
      for (const [x,y] of arr) {
        if (x>=x0 && x<x0+w && y>=y0 && y<y0+h) continue;
        out.push([x,y]);
      }
      out.sort((a,b)=>a[1]-b[1]||a[0]-b[0]);
      if (layer === 0) state.layers.collision_layer_1 = out; else state.layers.collision_layer_2 = out;
      await fetch('/api/state', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({data: state})});
      draw();
    };
    btnDelete.onclick = async () => {
      if (!sel.has) return;
      const x0 = Math.min(sel.sx, sel.ex), y0 = Math.min(sel.sy, sel.ey);
      const w = Math.abs(sel.ex - sel.sx) + 1, h = Math.abs(sel.ey - sel.sy) + 1;
      const r = await fetch('/api/delete', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({x:x0, y:y0, w, h})});
      const out = await r.json();
      // refresh patches from state
      await fetchState();
    };
    saveBtn.onclick = async () => {
      if (!state) return;
      await fetch('/api/state', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({data: state})});
      alert('Saved');
    };

    resize();
    fetchState();
  </script>
</body>
</html>


